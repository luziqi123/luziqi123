<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一个瞎BB的人">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr.LongFace">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mr.LongFace">
<meta property="og:description" content="一个瞎BB的人">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.LongFace">
<meta name="twitter:description" content="一个瞎BB的人">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Mr.LongFace </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mr.LongFace</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/05/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/README/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T03:56:17+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>忽略此处</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/04/Android/Android App 成长日记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/04/Android/Android App 成长日记/" itemprop="url">
                  Android App 成长日记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-04T00:00:00+08:00">
                2017-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/03/Android/Android Studio 打jar包 arr包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/03/Android/Android Studio 打jar包 arr包/" itemprop="url">
                  Android Studio 下导出带混淆Jar包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-03T00:00:00+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-Studio-下导出带混淆Jar包"><a href="#Android-Studio-下导出带混淆Jar包" class="headerlink" title="Android Studio 下导出带混淆Jar包"></a>Android Studio 下导出带混淆Jar包</h1><p>偶然间遇到了将Module打成jar包的需求 , 并且需要混淆 , 网上很多资料都有些不尽人意 , 这里分享一下操作流程 .  </p>
<ol>
<li>首先你要有一个Android Library的Module , 并已经跟主Module为依赖关系 .</li>
<li>然后在这个Module下的build.gradle中加入如下代码 , 注释已经很清楚了 . </li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">task clearJar(type: Delete) &#123;</div><div class="line">    delete 'build/libs/XXX.jar'////这行表示如果你已经打过一次包了，再进行打包则把原来的包删掉</div><div class="line">&#125;</div><div class="line"></div><div class="line">task makeJar(type: Copy) &#123;</div><div class="line">    from('build/intermediates/bundles/release/') //这行表示要打包的文件的路径，根据下面的内容，其实是该路径下的classes.jar</div><div class="line">    into('build/libs/')  //这行表示打包完毕后包的生成路径，也就是生成的包存在哪</div><div class="line">    include('classes.jar')  //看到这行，如果你对分包有了解的话，你就可以看出来这行它只是将一些类打包了</div><div class="line">    rename ('classes.jar', 'XXX.jar')</div><div class="line">&#125;</div><div class="line"></div><div class="line">makeJar.dependsOn(clearJar, build)</div><div class="line"></div><div class="line">task proguard(type: proguard.gradle.ProGuardTask, dependsOn: makeJar) &#123;</div><div class="line">//  输入路径</div><div class="line">    injars "build/libs/XXX.jar"</div><div class="line">//  输出路径</div><div class="line">    outjars 'libs/XXX.jar'</div><div class="line">//  添加配置信息</div><div class="line">    configuration 'proguard-rules.pro'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled true // 这里需要改为true, 启用混淆功能</div><div class="line">           proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>因为开启了混淆功能 , 你提供的接口或某些类不应该参与混淆 , 所以需要配置<code>proguard-rules.pro</code>文件 :</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-libraryjars 'C:\Program Files\Java\jdk1.8.0_20\jre\lib\rt.jar'</div><div class="line">-libraryjars 'C:\Users\AAAA\AppData\Local\Android\aaa\sdk\platforms\android-21\android.jar'</div><div class="line">-optimizationpasses 5 // 混淆等级</div><div class="line">-keep class com.ooo.toothbrush.api.** &#123;*;&#125;  // com.ooo.toothbrush.api下的所有类都不参与混淆</div><div class="line">-keep class com.ooo.toothbrush.callback.** &#123;*;&#125; // 同上</div></pre></td></tr></table></figure>
<ol>
<li>在Android Studio下的Terminal命令行窗口中执行 <code>gradlew makeJar</code>命令 , 稍等片刻……</li>
<li>成功之后会显示 <code>BUILD SUCCESSFUL</code> . 在你Module下的build/libs 就会出现一个jar包了 , 是他是他就是他 . </li>
</ol>
<p>至此 jar包导出完毕 . </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/26/Android/Android性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/26/Android/Android性能优化/" itemprop="url">
                  Android性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-26T00:00:00+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><h2 id="防止内存泄漏——夜用大片防侧漏"><a href="#防止内存泄漏——夜用大片防侧漏" class="headerlink" title="防止内存泄漏——夜用大片防侧漏"></a>防止内存泄漏——夜用大片防侧漏</h2><p>JAVA是在JVM所虚拟出的内存环境中运行的，JVM的内存可分为三个区：堆(heap)、栈(stack)和方法区(method)。</p>
<p><strong>栈(stack)</strong></p>
<p>是简单的数据结构，但在计算机中使用广泛。栈最显著的特征是：LIFO(Last In, First Out, 后进先出)。比如我们往箱子里面放衣服，先放入的在最下方，只有拿出后来放入的才能拿到下方的衣服。栈中只存放基本类型和对象的引用(不是对象)。</p>
<p><strong>堆(heap)</strong></p>
<p>堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。</p>
<p><strong>方法区(method)</strong></p>
<p>又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。当然这个区在这里不会参与讨论了 .</p>
<p>在JAVA中<strong>JVM的栈记录了方法的调用</strong>，每个线程拥有一个栈。在线程的运行过程当中，执行到一个新的方法调用，就在栈中增加一个内存单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。然而JAVA中的局部变量只能是基本类型变量(int)，或者对象的引用。所以在<strong>栈中只存放基本类型变量和对象的引用。引用的对象保存在堆中。</strong></p>
<p>当某方法运行结束时，该方法对应的frame将会从栈中删除，frame中所有局部变量和参数所占有的空间也随之释放。线程回到原方法继续执行，当所有的栈都清空的时候，程序也就随之运行结束。</p>
<p>如果我们不停的创建新对象，堆(heap)的内存空间就会被消耗尽。所以JAVA引入了垃圾回收(garbage collection，简称GC)去处理堆内存的回收，但如果对象一直被引用无法被回收，造成内存的浪费，无法再被使用。所以<strong>对象无法被GC回收就是造成内存泄露的原因.</strong></p>
<p>GC会从根节点（GC Roots）开始对heap进行遍历 , 到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。</p>
<p><strong>实现思想如下</strong>：JVM中有一个栈用于存放引用 , 一个堆用于存放对象 . 遍历栈中所有的对象的引用，再遍历一遍堆中的对象。因为栈中的对象的引用执行完毕就删除，所以我们就可以通过栈中的对象的引用，查找到堆中没有被指向的对象，这些对象即为不可到达对象，对其进行垃圾回收。</p>
<blockquote>
<p><strong>思考 :</strong> 话说堆内存是一个二叉树的数据结构 , 为什么用二叉树 ? 首先查找方便 , 在一个就是 , 如果占内存中的引用被删除了 , 那么堆内存中的对象将永远访问不到了 , 这时需要一个自己的引用 , 而二叉树恰好能通过这种引用让每一个对象都不会被遗漏 . 但每一次垃圾回收的动作都要遍历这颗树 ? 而对于垃圾回收的时机 , 什么时候才去执行一次垃圾回收 ? 记录对象分配的次数么 ? 到达一定值就清理一次 , 还是别的什么 ?</p>
</blockquote>
<p><a href="http://it.deepinmind.com/gc/2014/03/26/babys-first-garbage-collector.html" target="_blank" rel="external">自己动手写GC</a></p>
<p>垃圾回收器不会回收GC Roots以及那些被它们间接引用的对象。GC Roots有如下几种类型 , 也就是说每一种类型都对应一个root , 这意味着会有以下这些类型的root持有你的对象 , 再简单点说就是你创建的对象可能被存储在以下几个类型的二叉树中 . 需要注意的是 一个对象可以同时属于一个以上的root .  <strong>被这些root持有的对象不会被当做垃圾回收 .</strong> </p>
<ul>
<li><p><strong>Class</strong> </p>
<p>应用运行过程中非动态加载的类都是通过<code>dalvik.system.PathClassLoader</code>的实例加载到虚拟机中的。这些类对象是GC root的一种，它们带来的静态变量永远不会被垃圾回收。因此，静态变量持有的“过期”对象将会造成内存泄漏。</p>
<p>例如 : 单例时候的 getInstance(Context context) , 如果你传进来的是一个Activity , 那这个Activity可就没机会投胎了 .</p>
</li>
<li><p><strong>Thread</strong> </p>
<p>激活状态的线程是不会被GC回收的，所以它持有的对象也不会被回收。</p>
<p>例如 : 你创建了一个Runnable或AsyncTask之类的线程 , 并在线程中引入了一个Context , 如果恰巧这个Context是一个Activity…它会和上面提到的那个一样惨 .</p>
</li>
</ul>
<ul>
<li><p><strong>Stack Local</strong> </p>
<p>栈中的对象。上面已经说过了 , JVM中有一个栈来记录方法的调用 , 而在这个栈中也存放着一些局部变量和参数 . 他们是不会被回收的 , 因为随时可能会用到 .</p>
</li>
</ul>
<ul>
<li><p><strong>JNI Local</strong>  / <strong>JNI Global</strong> </p>
<p>JNI中的局部 / 全局变量和参数引用的对象 , 可能在JNI中定义的，也可能在虚拟机中定义 . </p>
<p>JNI Local  和 JNI Global 这些对象不止被Java代码中的引用持有，也会被虚拟机中的底层代码持有。<strong>在将持有它们的引用设置为null之前，要先将他们<code>close()</code>掉</strong>。还有一个特殊的类是<code>Bitmap</code>。在Android系统3.0之前，它的内存一部分在虚拟机中，一部分在虚拟机外。因此它的一部分内存不参与垃圾回收，需要我们主动调用<code>recycler()</code>才能回收。以及IO等一些流操作 . </p>
</li>
</ul>
<ul>
<li><p><strong>Monitor Used</strong> </p>
<p>用于保证同步的对象，例如wait()，notify()中使用的对象、锁等。</p>
</li>
</ul>
<ul>
<li><p><strong>Held by JVM</strong> </p>
<p>JVM持有的对象。JVM为了特殊用途保留的对象，它与JVM的具体实现有关。比如有System Class Loader, 一些Exceptions对象，和一些其它的Class Loader。对于这些类，JVM也没有过多的信息。</p>
<p><a href="http://www.jianshu.com/p/f5582d9a0f73" target="_blank" rel="external">Android开发从GC root分析内存泄漏</a></p>
<p><a href="http://stackoverflow.com/questions/6366211/what-are-the-roots" target="_blank" rel="external">What are the roots?</a></p>
</li>
</ul>
<p>这些是关于GC的一些简单介绍 ,  接下来将介绍一些常见的优化手段 . </p>
<hr>
<h3 id="Handler的正确写法"><a href="#Handler的正确写法" class="headerlink" title="Handler的正确写法"></a>Handler的正确写法</h3><p>正常情况下，本着方便快捷，省时省力的思想，我们会将Handler写成这副德性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="comment">// TODO you have message</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是如果你用的是Android Studio，那么他会报一片屎黄屎黄的颜色，那是因为Android Studio的Inspect Code检出出了这里可能会造成内存泄漏，Inspect Code可以检查你的代码并标记出可能出现问题的地方，后面的优化工具篇会讲到，回到正题，鼠标放在小灯泡的图标上，你就会看到这些东西：</p>
<blockquote>
<p>Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.</p>
</blockquote>
<p>他主要是告诉你，这里你声明了一个内部类，他会阻碍GC回收垃圾，哔哩哔哩……<br>用代码说话，错误示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    <span class="comment">// 发送一个10分钟后执行的一个消息</span></div><div class="line">    mHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    &#125;, <span class="number">600000</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 结束当前的Activity</span></div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当Activity结束后，在 Message queue 处理这个Message之前，它会持续存活着。这个Message持有Handler的引用，而Handler有持有Activity(SampleActivity)的引用，这个Activity所有的资源，在这个消息处理之前都不能也不会被回收，所以发生了内存泄露。</p>
<p>辣么，正确的写法应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> MyHandler handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">// 当参数为null的时候，可以清除掉所有跟次handler相关的Runnable和Message，我们在onDestroy中调用次方法也就不会发生内存泄漏了。</span></div><div class="line">        handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">todoHandler</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">        <span class="comment">// TODO handlerMessage</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span> </span>&#123;</div><div class="line">            mActivity = <span class="keyword">new</span> WeakReference(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            MainActivity mainActivity = mActivity.get();</div><div class="line">            <span class="keyword">if</span> (mainActivity != <span class="keyword">null</span>)&#123;</div><div class="line">                mainActivity.todoHandler(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果你觉得这么写太TM麻烦了，不用担心，嫌麻烦的不止你一个，总有受不了的，这里提供一个WeakHandler库 ： <a href="https://github.com/badoo/android-weak-handler" target="_blank" rel="external">GitHub</a></p>
<p><strong>这里再提供一个我感觉比较好的写法，自己觉得可以，但是不知道对不对</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现Handler.Callback接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivitySigin</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Handler mHandler;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_sigin_new);</div><div class="line">		</div><div class="line">		<span class="comment">// 创建Handler，将自己的实例传进去</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO 处理handler消息</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="单例，不仅仅存在线程安全问题"><a href="#单例，不仅仅存在线程安全问题" class="headerlink" title="单例，不仅仅存在线程安全问题"></a>单例，不仅仅存在线程安全问题</h3><p>单例模式深受广大开发者的喜爱，但从相对论的角度来看，肉吃多了也能死人。所以，在适合的情况下使用单例。而在单例的实现方式上，更多人关注线程安全方面的问题，但是内存泄漏问题同样重要。<br>在用LeakCanary检测APP内存泄漏的时候，发现N多地方出现了单例造成的内存泄漏。<br>下面来看一段反面教材：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXManager</span></span>&#123;  </div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> XXXManager instance;</div><div class="line">	<span class="keyword">private</span> Context context;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">XXXManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">	    <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XXXManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> XXXManager(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>XXXManager实例是存在于整个app生命周期的，如果是传入的Application完全没有问题，但如果你传入的是某个Activity，那么这个不幸的Context就跟死了没法儿投胎一样的跟着XXXManager，况且如果你在调用getInstance()之前这个实例已经存在了，那么你传入的这个Context并没有什么卵用。下面给出两个方案，我认为第二个会好一点。<br>方案1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">XXXManager</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">	<span class="comment">// 这样你持有的就是Application的Context了，没毛病~</span></div><div class="line">	<span class="keyword">this</span>.context = context.getApplication();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方案2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XXXManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">if</span> (mContext != <span class="keyword">null</span>)&#123;</div><div class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</div><div class="line">              instance = <span class="keyword">new</span> XXXManager(mContext);</div><div class="line">          &#125;</div><div class="line">           <span class="keyword">return</span> instance;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 如果mContext = null 抛出异常提醒没有注册过</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"not register!"</span>);</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 在MyApplication中先注册</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">       mContext = context;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里为了突出重点，忽略了线程安全，使用的时候需要注意到这一点。</p>
<hr>
<h3 id="多线程的滥用——你用多少内存换来懒惰？"><a href="#多线程的滥用——你用多少内存换来懒惰？" class="headerlink" title="多线程的滥用——你用多少内存换来懒惰？"></a>多线程的滥用——你用多少内存换来懒惰？</h3><p>我相信很多人都这么干过：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">     &#125;</div><div class="line">   &#125;).start();</div></pre></td></tr></table></figure></p>
<p>这里的Runnable和前面提到的错误书写handler一样，是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，那么将导致Activity的内存资源无法回收，造成内存泄漏。<br>同Handler的解决方法一样，你需要使用一个静态的内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		SystemClock.sleep(<span class="number">10000</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>在Android studio中我们可以方便的看到App运行时的内存使用情况，下面这张图就是典型的内存抖动了， 内存抖动是因为大量的对象被创建又在短时间内马上被释放。<br>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p>
<p><img src="http://img.blog.csdn.net/20170224132942416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>解决方法也比较简单，当出现问题时，多半是在for循环中分配对象占用内存，或者在自定义的onDraw()中做了构建对象的操作或其他复杂操作，如若真的无法避免，你可以考虑使用对象池来管理这些需要被大量创建的对象，我们在工具篇也介绍了如何定位到问题所在。</p>
<hr>
<h3 id="选择合适的容器"><a href="#选择合适的容器" class="headerlink" title="选择合适的容器"></a>选择合适的容器</h3><p>####ArryaMap<br>ArrayMap是Android提供的用来替代HashMap的集合<br>对象个数的数量级在千以内<br>数据组织形式包含Map结构<br>这时使用ArrayMap就相比HashMap节省内存，并且在遍历速度上也更胜一筹。<br>具体为什么，请看下图：<br><img src="http://img.blog.csdn.net/20170224133249318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br><a href="https://liuzhichao.com/p/832.html" target="_blank" rel="external">原文地址</a></p>
<p>####Sparse系列<br>为了避免HashMap的自动装箱（autoboxing）行为，Android系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。</p>
<p>另外这些容器的使用场景也和ArrayMap一致，需要满足数量级在千以内，数据组织形式需要包含Map结构。</p>
<hr>
<p>###for循环的秘密<br>遍历容器是编程里面一个经常遇到的场景。在Java语言中，使用Iterate是一个比较常见的方法。可是在Android开发中，大家却尽量避免使用Iterator来执行遍历操作。下面我们看下在Android上可能用到的三种不同的遍历方法：<br><img src="http://img.blog.csdn.net/20170224133014096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>他们的执行速度分别是这样的：<br><img src="http://img.blog.csdn.net/20170224133024315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>从上面可以看到<strong><em>for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式</em></strong>。</p>
<hr>
<h3 id="你所不知道的枚举真面目"><a href="#你所不知道的枚举真面目" class="headerlink" title="你所不知道的枚举真面目"></a>你所不知道的枚举真面目</h3><p>枚举往往需要超过一倍多的内存静态常量。在Android中你应该严格避免使用枚举。<br>总的来说枚举更耗内存，并且在编译之后的dex文件也会占用更多的空间。</p>
<blockquote>
<p>Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>
</blockquote>
<hr>
<h1 id="UI优化"><a href="#UI优化" class="headerlink" title="UI优化"></a>UI优化</h1><h2 id="真的是越小越好"><a href="#真的是越小越好" class="headerlink" title="真的是越小越好"></a>真的是越小越好</h2><p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。<br><img src="http://img.blog.csdn.net/20170224133005900?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>另外尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过setLayerType()方法使得这个View强制用Hardware来进行渲染。</p>
<hr>
<h2 id="16ms"><a href="#16ms" class="headerlink" title="16ms"></a>16ms</h2><p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，这称作一帧，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps（1000 / 16 = 62.6），这意味着程序的大多数操作都必须在16ms内完成。<br><img src="http://img.blog.csdn.net/20170224132838493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>例如在滑动ListView的时候经常出现卡顿的现象，很可能就是因为item的布局太过复杂，加载时间超过了16ms，这种情况就是丢帧了。</p>
<p>也许是因为你的layout太过复杂，无法在16ms内完成渲染，有可能是因为你的UI上有层叠太多的绘制单元，还有可能是因为动画执行的次数过多。这些都会导致CPU或者GPU负载过重。</p>
<p>我们可以通过一些工具来定位问题，比如可以使用HierarchyViewer来查找Activity中的布局是否过于复杂，也可以使用手机设置里面的开发者选项，打开Show GPU Overdraw等选项进行观察。你还可以使用TraceView来观察CPU的执行情况，更加快捷的找到性能瓶颈。</p>
<hr>
<h2 id="小心Bitmap"><a href="#小心Bitmap" class="headerlink" title="小心Bitmap"></a>小心Bitmap</h2><p>在开发过程中，我们或多或少的会用到Bitmap，但是如果处理不当，就会发生OOM或是让你的程序变的卡顿并异常的消耗内存，对于Bitmap，我们应该清楚以下几点：</p>
<h4 id="如何高效的加载大图"><a href="#如何高效的加载大图" class="headerlink" title="-如何高效的加载大图"></a><strong>-如何高效的加载大图</strong></h4><p>在大多数情况下，图片的实际大小都比需要呈现的尺寸大很多，考虑到应用是在有限的内存下工作的，<strong><em>理想情况是我们只需要在内存中加载一个低分辨率的照片即可</em></strong>。这一小结我们会介绍如何通过加载一个缩小版本的图片，从而避免超出程序的内存限制。</p>
<p><strong><em>Android 提供了现成的API createScaledBitmap()来缩放一张图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。</em></strong>下面介绍其他几种缩放图片的方式。</p>
<p><strong><em>inSampleSize</em></strong></p>
<p>他能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。BitmapFactory提供了一些解码（decode）的方法（decodeByteArray(), decodeFile(), decodeResource()等），用来从不同的资源中创建一个Bitmap。 我们应该根据图片的数据源来选择合适的解码方法。 这些方法在构造位图的时候会尝试分配内存，因此会容易导致OutOfMemory的异常。每一种解码方法都可以通过BitmapFactory.Options设置一些附加的标记，以此来指定解码选项。</p>
<p><img src="http://img.blog.csdn.net/20170224132819306?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p><strong><em>设置 inJustDecodeBounds 属性为true可以在解码的时候避免内存的分配，它会返回一个null的Bitmap，但是可以获取到 outWidth, outHeight 与 outMimeType。该技术可以允许你在构造Bitmap之前优先读图片的尺寸与类型。</em></strong><br><strong><em>为了避免OOM 的异常，我们需要在真正解析图片之前检查它的尺寸</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *在不加载原图到内存的情况下获取到图片的实际宽高</div><div class="line"> */ </div><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">options.inJustDecodeBounds = true;</div><div class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</div><div class="line">int imageHeight = options.outHeight;</div><div class="line">int imageWidth = options.outWidth;</div><div class="line">String imageType = options.outMimeType;</div></pre></td></tr></table></figure>
<blockquote>
<p>例如，如果把一个大小为1024x768像素的图片显示到大小为128x96像素的ImageView上吗，就没有必要把整张原图都加载到内存中。</p>
<p>为了告诉解码器去加载一个缩小版本的图片到内存中，需要在BitmapFactory.Options 中设置 inSampleSize 的值。例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。加载这张缩小的图片仅仅使用大概0.75MB的内存，如果是加载完整尺寸的图片，那么大概需要花费12MB（前提都是Bitmap的配置是 ARGB_8888）。下面有一段根据目标图片大小来计算Sample图片大小的代码示例：</p>
</blockquote>
<p><em>使用下面这个方法可以简单地加载一张任意大小的图片。这里显示了一个接近 20X20像素的缩略图：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">main()&#123;</div><div class="line">	// 调用</div><div class="line">	imageView.setImageBitmap(</div><div class="line">                decodeSampledBitmapFromResource(</div><div class="line">                getResources() , </div><div class="line">                R.mipmap.ic_launcher , </div><div class="line">                20 , </div><div class="line">                20)</div><div class="line">        );</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">     * 从resource中解码一个图片</div><div class="line">     * @param res 图片的来源</div><div class="line">     * @param resId 图片的ID</div><div class="line">     * @param reqWidth 期望的宽度</div><div class="line">     * @param reqHeight 期望的高度</div><div class="line">     * @return 缩小版的Bitmap</div><div class="line">     */</div><div class="line">    public static Bitmap decodeSampledBitmapFromResource</div><div class="line">            (Resources res, int resId, int reqWidth, int reqHeight) &#123;</div><div class="line">        // 首先你需要解码并将inJustDecodeBounds设置为true,检查图片的大小</div><div class="line">        final BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">        options.inJustDecodeBounds = true;</div><div class="line">        BitmapFactory.decodeResource(res, resId, options);</div><div class="line"></div><div class="line">        // 计算inSampleSize的值</div><div class="line">        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</div><div class="line"></div><div class="line">        // 根据inSampleSize的值来解码图片</div><div class="line">        options.inJustDecodeBounds = false;</div><div class="line">        return BitmapFactory.decodeResource(res, resId, options);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据你所期望的宽高获取inSampleSize</div><div class="line">     * @param options 一个经过设置的BitmapFactory.Options</div><div class="line">     * @param reqWidth 期望图片的宽</div><div class="line">     * @param reqHeight 期望图片的高</div><div class="line">     * @return 一个合适的inSampleSize值</div><div class="line">     */</div><div class="line">    public static int calculateInSampleSize</div><div class="line">            (BitmapFactory.Options options, int reqWidth, int reqHeight) &#123;</div><div class="line">        // 记录未加工前的图片的宽高 初始化inSampleSize为1</div><div class="line">        final int height = options.outHeight;</div><div class="line">        final int width = options.outWidth;</div><div class="line">        int inSampleSize = 1;</div><div class="line"></div><div class="line">        if (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line"></div><div class="line">            final int halfHeight = height / 2;</div><div class="line">            final int halfWidth = width / 2;</div><div class="line"></div><div class="line">            // 当高度和宽度大于所要求的高度和宽度，将inSampleSize以2的幂增加，得到最大inSampleSize值</div><div class="line">            // 设置inSampleSize为2的幂是因为解码器最终还是会对非2的幂的数进行向下处理，获取到最靠近2的幂的数。</div><div class="line">            while ((halfHeight / inSampleSize) &gt; reqHeight</div><div class="line">                    &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</div><div class="line">                inSampleSize *= 2;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return inSampleSize;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理。</p>
<h4 id="提升bitmap的循环效率"><a href="#提升bitmap的循环效率" class="headerlink" title="-提升bitmap的循环效率"></a><strong>-提升bitmap的循环效率</strong></h4><p>// TODO 需要单独写一篇</p>
<h4 id="非UI线程处理Bitmap"><a href="#非UI线程处理Bitmap" class="headerlink" title="-非UI线程处理Bitmap"></a><strong>-非UI线程处理Bitmap</strong></h4><p>// TODO 需要单独写一篇</p>
<h4 id="Bitmap缓存"><a href="#Bitmap缓存" class="headerlink" title="-Bitmap缓存"></a><strong>-Bitmap缓存</strong></h4><p>// TODO 需要单独写一篇</p>
<hr>
<h2 id="优化你的布局"><a href="#优化你的布局" class="headerlink" title="优化你的布局"></a>优化你的布局</h2><p>用事实说话就是，曾经一个界面的运行内存是160M左右，单修改了布局的结构就下降到了140M左右。当然，优化布局最终要的是让你的界面变的更流畅，我们可以通过HierarchyViewer这个工具来查看布局(工具篇有讲到)，使得布局尽量扁平化，移除非必需的UI组件，这些操作能够减少Measure，Layout的计算时间。</p>
<p>对于布局优化，有以下几点建议：</p>
<h4 id="merge和include——减少节点"><a href="#merge和include——减少节点" class="headerlink" title="-merge和include——减少节点"></a><strong><em>-merge和include——减少节点</em></strong></h4><p>在一些无需太多属性的根节点上，你可以使用merge，他会为你减少一层节点，如果你想优化你的布局，减少节点是第一步要做的，通过include将这些merge为根节点的布局引入进来，再用HierarchyViewer看一下你的层级吧，它变的更扁平化了。</p>
<p><em>示例代码：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;merge</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_width=&quot;30dp&quot;</div><div class="line">        android:layout_height=&quot;30dp&quot;</div><div class="line">        android:src=&quot;@mipmap/ic_launcher&quot;/&gt;</div><div class="line">    </div><div class="line">    &lt;ImageView</div><div class="line">        android:layout_marginTop=&quot;30dp&quot;</div><div class="line">        android:layout_width=&quot;30dp&quot;</div><div class="line">        android:layout_height=&quot;30dp&quot;</div><div class="line">        android:src=&quot;@mipmap/ic_launcher&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/merge&gt;</div></pre></td></tr></table></figure></p>
<h4 id="viewstub——优化预加载"><a href="#viewstub——优化预加载" class="headerlink" title="-viewstub——优化预加载"></a><strong><em>-viewstub——优化预加载</em></strong></h4><p>这是一个神奇的控件，像公关小姐一样召之即来挥之即去，在你不需要她的时候绝对不会给你添麻烦，viewstub引入的布局默认不会扩张，不会占用显示位置，不参与任何的布局和绘制过程，从而在解析layout时节省cpu和内存。它的意义在于按需加载布局文件，比如网络异常的界面正常情况下是不会显示的，我们就没有必要在初始化的时候就把它加载进来。</p>
<p>需要注意的是:</p>
<ol>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。</li>
</ol>
<p><em>示例代码：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private View mStubView;</div><div class="line">   </div><div class="line">   /**</div><div class="line">    * 显示这个布局</div><div class="line">    */</div><div class="line">   public void comeBaby()&#123;</div><div class="line">       // 避免重复加载</div><div class="line">       if (mStubView == null)&#123;</div><div class="line">           ViewStub stub = (ViewStub) findViewById(R.id.view_stub);</div><div class="line">           mStubView = stub.inflate();</div><div class="line">       &#125;</div><div class="line">       mStubView.setVisibility(View.VISIBLE);</div><div class="line">       Button btn1 = (Button) mStubView.findViewById(R.id.btn1);</div><div class="line">       Button btn2 = (Button) mStubView.findViewById(R.id.btn2);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="别让你的APP太多层——过渡绘制"><a href="#别让你的APP太多层——过渡绘制" class="headerlink" title="-别让你的APP太多层——过渡绘制"></a><strong>-别让你的APP太多层——过渡绘制</strong></h4><p>在开发者选项中打开调试GPU绘制，模拟器上叫Show GPU Overdraw ，不同机型名字也不一样，大概就这个意思，然后你就会看到你的屏幕跟坏了似得花花绿绿。这时候，你就可以去换一台手机了O(∩_∩)O。<br>开玩笑……这些了花花绿绿的分别代表了某个区域的绘制情况。<br><img src="http://img.blog.csdn.net/20170224132854071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>简而言之就是，红色严重，粉色严重，绿色说得过去，蓝色正常。</p>
<p>有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p>
<h3 id="硬件加速-Hardware-Accelerated"><a href="#硬件加速-Hardware-Accelerated" class="headerlink" title="硬件加速 Hardware Accelerated"></a><strong><em>硬件加速 Hardware Accelerated</em></strong></h3><p> Android从3.0（API Level 11）开始，在绘制View的时候支持硬件加速，充分利用GPU的特性，使得绘制更加平滑，但是会多消耗一些内存。</p>
<p><strong>开启硬件加速：</strong></p>
<p>Application级别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</div></pre></td></tr></table></figure></p>
<p>Activity级别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;application android:hardwareAccelerated=&quot;true&quot;&gt;</div><div class="line">    &lt;activity ... /&gt;</div><div class="line">    &lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt;</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure></p>
<p>Window级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(</div><div class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</div><div class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</div></pre></td></tr></table></figure></p>
<p>View级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div></pre></td></tr></table></figure></p>
<p><strong>开启后的绘制区别：</strong></p>
<ol>
<li><p>没有硬件加速：invalidate the view hierarchy ——&gt; draw the view hierarchy</p>
</li>
<li><p>有硬件加速：invalidate the view hierarchy ——&gt; record and update the display list ——&gt; draw the display list</p>
</li>
</ol>
<p><strong>开启硬件加速之后的异常反应：</strong></p>
<ol>
<li><p>某些UI元素没有显示：可能是没有调用invalidate</p>
</li>
<li><p>某些UI元素没有更新：可能是没有调用invalidate</p>
</li>
<li><p>绘制不正确：可能使用了不支持硬件加速的操作， 需要关闭硬件加速或者绕过该操作</p>
</li>
<li><p>抛出异常：可能使用了不支持硬件加速的操作， 需要关闭硬件加速或者绕过该操作</p>
</li>
</ol>
<p><strong>下表为硬件加速不支持的绘制操作：</strong></p>
<p><img src="http://img.blog.csdn.net/20170224132955447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br><img src="http://img.blog.csdn.net/20170224134117218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br><img src="http://img.blog.csdn.net/20170224134117218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<h3 id="需要慎用的透明度"><a href="#需要慎用的透明度" class="headerlink" title="需要慎用的透明度"></a><strong><em>需要慎用的透明度</em></strong></h3><p>这小节会介绍如何减少透明区域对性能的影响。通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。原因是包含alpha的view需要事先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。在某些情况下，一个包含alpha的View有可能会触发该View的父控件都被额外重绘一次。</p>
<p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理。</p>
<p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">convertView.setLayerType(View.LAYER_TYPE_HARDWARE , null);</div></pre></td></tr></table></figure>
<p>对于一些不存在层叠关系的View，我们可以重写hasOverlappingRendering()方法来让渲染器知道这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Override</div><div class="line">hasOverlappingRendering()&#123;</div><div class="line">	return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这张图是设置后的情况：</p>
<p><img src="http://img.blog.csdn.net/20170224133033596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a><strong>电量优化</strong></h2><ul>
<li>AP 和 BP</li>
<li>唤醒屏幕<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a><strong>网络优化</strong></h2></li>
<li>打包发送网络请求<h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a><strong>关于生命周期</strong></h2></li>
<li>在onCreate中处理你的复活状态<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a><strong>代码结构</strong></h2></li>
<li>全局通知机制</li>
</ul>
<h2 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a><strong>优化工具</strong></h2><p><strong><em>Android SDK包含了许多工具来帮助我们开发Android App，这些工具呢大概分为两类：SDK工具和平台工具。SDK工具是独立于平台之外的，而平台工具是为了支持最新的Android开发平台而定制的。</em></strong></p>
<h3 id="Hierarchy-Viewer-——-检查你的布局"><a href="#Hierarchy-Viewer-——-检查你的布局" class="headerlink" title="Hierarchy Viewer —— 检查你的布局"></a><strong><em>Hierarchy Viewer —— 检查你的布局</em></strong></h3><p>Hierarchy Viewer是我们的布局文件的层级结构变的可见，并且在每一个节点标注此节点的性能相关的信息。通过此工具可以详细的理解当前界面的控件布局以及某个控件的属性（name、id、height等）。同时，我们可以借助Hierarchy Viewer学习别人优秀的布局方式，也能更深入更全面更整体的把握xml布局文件。<br>Android studio中，你更是可以方便的使用他：<br><img src="http://img.blog.csdn.net/20170224132718149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>然后点击这里：<br><img src="http://img.blog.csdn.net/20170224132901900?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>在弹框中选择Hierarchy Viewer。<br>之后我们就可以看到这么一张图：<br><img src="http://img.blog.csdn.net/20170224132910103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>每一个小方格就代表了一个View，从左至右的顺序代表了层级关系，上面最显眼的三个点分别代表了：计算宽高时间、放置布局时间、绘制时间。和你想象的一样，绿色合格，黄色警告，红色超时。<br>点击对应的控件，可以详细的看到他分别在绘制流程的每一步花费具体花费了多长时间。</p>
<p><em>Android系统出于安全考虑，Hierarchy Viewer只能连接开发版手机或模拟器</em>，我们普通的商业手机是无法连上的（老版本的Hierarchy Viewer可以），这一限制在<br>frameworks/base/services/java/com/android/server/wm/WindowManageService.java<br>cmd下执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell service call window 3</div></pre></td></tr></table></figure></p>
<p>若返回值是：Result: Parcel(00000000 00000000 ‘……..’) 说明View Server处于关闭状态<br>若返回值是：Result: Parcel(00000000 00000001 ‘……..’) 说明View Server处于开启状态<br>如果不嫌麻烦可以参照这里<a href="http://blog.csdn.net/autumn_xl/article/details/40741835" target="_blank" rel="external">连接真机教程</a><br>但是我比较懒，就直接装了一个小米的开发版系统，执行adb开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 开启</div><div class="line">adb shell service call window 1 i32 4939</div><div class="line">// 关闭</div><div class="line">adb shell service call window 2 i32 4939</div></pre></td></tr></table></figure></p>
<p>如果你连系统也不想刷就下载个Genymotion来用吧，很棒的虚拟机。<br>如果这个也不想下，那你的布局肯定没毛病~</p>
<h3 id="TraceView——关心你的CPU占用时长"><a href="#TraceView——关心你的CPU占用时长" class="headerlink" title="TraceView——关心你的CPU占用时长"></a><strong><em>TraceView——关心你的CPU占用时长</em></strong></h3><p>TraceView可以用图表的方式告诉你，哪些线程在CPU中占用了太长时间，但是界面之复杂程度……着实不是一般人能看懂的。<br>而Android studio中对此做了优化，我们最常看的LogCat的右边：<br><img src="http://img.blog.csdn.net/20170224132916165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"> </p>
<p>点开后可以看到你的CPU使用情况，点击下图中的小闹钟开始，再隔一段时间后再次点击它结束：<br><img src="http://img.blog.csdn.net/20170224132931150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>然后你就会看到下面这个界面了：<br><img src="http://img.blog.csdn.net/20170224132923040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>选中Color by inclusive time 就可以快速的预览各个线程占用CPU的时间。谁是最慢的短板？想办法优化它吧！</p>
<h3 id="一只鼻子灵敏的DOG——MAT内存分析"><a href="#一只鼻子灵敏的DOG——MAT内存分析" class="headerlink" title="一只鼻子灵敏的DOG——MAT内存分析"></a><strong><em>一只鼻子灵敏的DOG——MAT内存分析</em></strong></h3><p>MAT这个工具可以将内存空间的现状展现的淋漓尽致，这里会让你快速认识并使用它找到内存泄露的地方。<br>首先说下运行环境，这里使用的是Android studio + MAT。<br><a href="http://pan.baidu.com/s/1cp1PpW" target="_blank" rel="external">用力戳我下载MAT</a><br>你需要完成以下步骤：</p>
<ol>
<li><strong>在Android studio的内存监测中获取某个时刻的内存情况。</strong><br>打开App，开始正常使用吧，最后，我建议你回到你进入到app的第一个界面。<br>然后在内存监测中调用GC回收掉可以被回收的垃圾，此时内存中只剩下无法被回收的一部分了，不管他是否应该被回收。<br><img src="http://img.blog.csdn.net/20170224133105675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>然后点这里，Dump Java Heap:<br><img src="http://img.blog.csdn.net/20170224133044128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>你会看到一个这样的图标出现在了内存显示区<img src="http://img.blog.csdn.net/20170224133052690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>可能需要等一会儿，上个厕所什么的，小的就可以 ，大的就过长了…这期间他会将这一时刻的内存情况分析出来并保存成一个.hprof的文件。<br>你可以在这里找到他，在第三项Captures：<br><img src="http://img.blog.csdn.net/20170224133113941?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>然后右键—&gt;Export to standard .hprof 导出，你需要选择一个路径，我建议新建一个文件夹，如果你听了我的建议，用过之后你会感谢我的。</li>
<li><strong>在MAT中打开刚才导出的文件</strong><br>至此我们已经得到了你的内存分析报告，那给医生去看吧，打开MAT，File—&gt;Open Heap Dump,就可以看到分析结果了。</li>
<li><strong>定位</strong><br>网上很多资料，但是对于如何定位问题很笼统，今天就让本菜手把手 嘴对嘴的告诉你。<br>首先点击这里，可以看到更详细的统计：<br><img src="http://img.blog.csdn.net/20170224133121010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>一看都不认识，脸一黑，都啥<em>**</em>东西（*号部分自由发挥），如果你这么想，你需要点这里：<br><img src="http://img.blog.csdn.net/20170224133141988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></li>
</ol>
<p>选中最后一项，就可以以包名分类来看这些条目了，应该知道怎么做了，找到你的项目com.ex…巴拉巴拉，你会看到刚才涉及到的对象都在这里出现了，分别有4个tab, 第一个是name第二个是Object，就是这个对象当前存在实例的个数，右边还有两个这里不说了，因为我没用到，也不敢瞎BB……<br>如果你有内存泄露的情况，就会看到这样的现象：</p>
<p><img src="http://img.blog.csdn.net/20170224133232114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p><img src="http://img.blog.csdn.net/20170224135135895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>我的BrushActivity明明早就隔儿屁了，怎么还有一个实例存在，你可以右键—&gt;Merge Shortest Paths to GC Roots  —&gt; exclude weak/soft references ，看是谁脱离了Root的节点：<br><img src="http://img.blog.csdn.net/20170224135037426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>被我画红线的地方写了包名，你可以很容易的找到问题所在了。这里可以清楚的知道，这是因为一个线程持有了activity的实例，而线程又是一个AnimationSet动画线程，在MoveParticleView中，自己挖的坑儿，应该会想到问题所在了。</p>
<p>至此，就没了……没了……</p>
<h3 id="分配追踪，Allocation-Tracking"><a href="#分配追踪，Allocation-Tracking" class="headerlink" title="分配追踪，Allocation Tracking"></a><strong><em>分配追踪，Allocation Tracking</em></strong></h3><p>看完了上一小节，再来看下一小节……戳完了上节的按钮，肯定有不少人想戳下面的，这里我就好奇了，一戳惊喜不断呀。<br><img src="http://img.blog.csdn.net/20170224133218426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"><br>使用很简单，点第一下开始，点第二下结束，然后他会分析出在这期间你的内存分配情况。正好项目里有个地方出现了内存抖动，检测一下吧。<br>看到检测结果，都不认识，脸一黑，都啥<em>**</em>东西（*号部分自由发挥），如果你这么想，你需要点这里：<br><img src="http://img.blog.csdn.net/20170224133156448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>第一个是以方法分组，第二个是以包名，想都不想肯定用包名。</p>
<p><img src="http://img.blog.csdn.net/20170224135514021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>这里看到brush包下居然分配了600个对象，点开，定位到了一个叫Renderer的类，右键，Jump to Source 打开源码，发现有一个方法一直在频繁调用，但是问题是从native中报出来的，So……放弃……但是总之是定位到问题所在了。<br>在上图中还看到一个饼状图一样的按钮，点他会出现一个很炫酷的饼状图，并且可以在柱状和饼状之间切换，可以点着看看，一目了然。</p>
<h3 id="Android-Lint——为你的Code体检"><a href="#Android-Lint——为你的Code体检" class="headerlink" title="Android Lint——为你的Code体检"></a><strong><em>Android Lint——为你的Code体检</em></strong></h3><p>从字面上我是这么理解的，Android Lint，Lint嘛！线头！安卓线头！它帮你找出你代码中可能出问题，书写不规范，可以优化的地方，不知道理解的对不对，求调教……没图我说个JB，直接上图：<br><img src="http://img.blog.csdn.net/20170224133332198?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<p>在这里你可以选择检查的范围，从上到下分别是，整个项目<br><img src="http://img.blog.csdn.net/20170224133339303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Alt text"></p>
<h1 id="关于性能优化的一些建议"><a href="#关于性能优化的一些建议" class="headerlink" title="关于性能优化的一些建议"></a>关于性能优化的一些建议</h1><p>以下摘自<android开发艺术探索>  和 <android群英传></android群英传></android开发艺术探索></p>
<ul>
<li>避免创建过多的对象</li>
<li>不要过多使用枚举 , 枚举占用的内存空间要比整形大</li>
<li>常量使用static final来修饰</li>
<li>使用一些Android特有的数据结构 , 比如SparseArray 和 Pair等 , 他们具有更好的性能 </li>
<li>适当使用软引用和弱引用 (软引用比较常用)</li>
<li>采用内存缓存和磁盘缓存</li>
<li>尽量采用静态内部类 , 这样可以避免由于内部类而导致的内存泄露</li>
<li>任何Java类 , 都将占用大约500字节的内存空间 , 创建一个实例大约消耗15字节的内存 .</li>
<li>可以定义为局部的变量不要定义为成员</li>
<li>避免频繁创建短作用域的变量</li>
<li>使用RenderScript , OpenGL来进行非常复杂的绘图操作</li>
<li>使用SurfaceView来完成频繁的绘图操作</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p><a href="http://hanks.xyz/2016/01/20/android-optimization" target="_blank" rel="external">Android 性能优化列表</a><br><a href="http://www.jianshu.com/p/5bb8c01e2bc7" target="_blank" rel="external">Android APP内存优化之图片优化</a><br><a href="http://www.kancloud.cn/kancloud/android-performance/53238" target="_blank" rel="external">Android 性能优化（谷歌官方）</a><br><a href="http://hukai.me/android-performance-patterns-season-2/" target="_blank" rel="external">Android性能优化1~4</a><br><a href="http://blog.csdn.net/sdkfjksf/article/details/50939425" target="_blank" rel="external">Android 布局优化</a></p>
<p>​    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/25/Android开发艺术探索读书笔记/2. Intent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Android开发艺术探索读书笔记/2. Intent/" itemprop="url">
                  Intent
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h1><p>Activity的启动分为显式和隐式,显式就是我们最常用的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivity(<span class="keyword">new</span> Intent(context , xxx.class));</div></pre></td></tr></table></figure>
<p>隐式调用则需要intent能够匹配目标组件intentFliter中所设置的过滤信息.</p>
<p>IntentFilter中的过滤信息有action   category  data,就像下面这样…..摘自<android开发艺术探索> 我从来没有这么用过…..</android开发艺术探索></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=".MainActivity"&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name="com.ryg.charpter_1.c"/&gt;</div><div class="line">        &lt;action android:name="com.ryg.charpter_1.d"/&gt;</div><div class="line">        &lt;category android:name="com.ryg.category.c"/&gt;</div><div class="line">        &lt;category android:name="com.ryg.category.d"/&gt;</div><div class="line">        &lt;data android:mimeType="text/plain"/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure>
<p>上面这个就是过滤列表了,需要同时匹配过滤列表中的action category data,否则失败.action等这些东西都可以有多个,只需要匹配其中一条就可以了.就像上面的这个,只需要匹配com.ryg.charpter_1.c 或 com.ryg.charpter_1.d 那么action就算匹配成功了.下面给出一个匹配上面intent-filter的Intent:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.setAction(<span class="string">"com.ryg.charpter_1.c"</span>);</div><div class="line">intent.addCategory(<span class="string">"com.ryg.category.d"</span>);</div><div class="line">intent.setDataAndType(Uri.parse(<span class="string">"file://abc"</span>) , <span class="string">"text/plain"</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>也可以有多个intent-filter, 如下,只要匹配其中一个intent-filter就可算匹配成功.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=".MainActivity"&gt;</div><div class="line">     &lt;intent-filter&gt;</div><div class="line">         &lt;action android:name="android.intent.action.SEND"/&gt;</div><div class="line">         &lt;category android:name="android.intent.category.DEFAULT"/&gt;</div><div class="line">         &lt;data android:mimeType="text/plain"/&gt;</div><div class="line">     &lt;/intent-filter&gt;</div><div class="line">     &lt;intent-filter&gt;</div><div class="line">         &lt;action android:name="android.intent.action.SEND"/&gt;</div><div class="line">         &lt;action android:name="android.intent.action.SEND_MULTIPLE"/&gt;</div><div class="line">         &lt;category android:name="android.intent.category.DEFAULT"/&gt;</div><div class="line">         &lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&gt;</div><div class="line">         &lt;data android:mimeType="image/*"/&gt;</div><div class="line">         &lt;data android:mimeType="video/*"/&gt;</div><div class="line">     &lt;/intent-filter&gt;</div><div class="line"> &lt;/activity&gt;</div></pre></td></tr></table></figure>
<h1 id="action的匹配规则"><a href="#action的匹配规则" class="headerlink" title="action的匹配规则"></a>action的匹配规则</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/25/Android开发艺术探索读书笔记/5. 理解RemoteViews/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Android开发艺术探索读书笔记/5. 理解RemoteViews/" itemprop="url">
                  理解RemoteView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="RemoteView"><a href="#RemoteView" class="headerlink" title="RemoteView"></a>RemoteView</h1><p>他可以在其他进程中显示 , 并提供一组可以跨进程更新界面的操作 . 在实际开发中 , 主要用在通知栏和桌面程序 .</p>
<p>他的主要作用就是在其他进程中显示并更新View界面 .</p>
<p>构造函数 : RemoteViews(String packageName , int layoutId) 第一个为包名 , 第二个为布局文件.  </p>
<p><strong>支持类型 :</strong></p>
<ol>
<li><p>Layout</p>
<p>FrameLayout </p>
<p>LinearLayout</p>
<p>RelativeLayout</p>
<p>GridLayout</p>
</li>
<li><p>View</p>
<p>AnalogClock</p>
<p>Button</p>
<p>Chronometer </p>
<p>ImageButton </p>
<p>ImageView </p>
<p>ProgressBar </p>
<p>TextView </p>
<p>ViewFlipper</p>
<p>ListView </p>
<p>GridView </p>
<p>StackView </p>
<p>AdapterViewFlipper </p>
<p>VIewStub</p>
</li>
</ol>
<p>再传入的布局文件中 , 只能出现上述View类型 , 子类和其他类型都不行. 例如使用了EditText , 则会抛异常 :</p>
<p>couldn’t inflate view for notification….</p>
<p>下面是一些常用set方法 : </p>
<p><img src="http://img.blog.csdn.net/20170215184510373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>内部机制 : </strong></p>
<p>通知栏和桌面小部件分别有NotificationManager和AppWidgetManager管理 , 而 NotificationMananger和AppWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService和AppWidgetManagerService进行通信 , 他们运行在SystemService中,  这就和我们的进程构成了跨进程通信 . </p>
<p>首先RemoteViews会通过Binder传递给SystemService进程 , 因为他实现了Parcelable接口, 系统根据他所包含的包名获取相应应用的资源 , 然后再根据他的布局文件加载布局 , 加载后只是一个普通View而已 .<br>RemoteViews提供了一个Action的概念 , Action同样实现了Parcelable接口 ,  它封装了一个对View的操作 . 我们每调用一次set方法 , RemoteViews就会添加一个对应的Action对象 . 当我们调用NotificationManager和AppWidgetManager来提交我们的更新时 , 这些Action就会被传输到远程进程 , 并在远程进程中一次执行 . 远程进程通过RemoteView的apply方法来进行View的更新操作.  而RemoteViews的apply方法内部则依次执行Action的apply方法 , 具体的View更新是通过Action的apply方法完成的 . </p>
<p>这样就避免了大量的IPC操作, 提高了性能 , 并且不用定义大量的Binder接口 .</p>
<p><img src="http://img.blog.csdn.net/20170215234522261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>暂不记录 , 详情见233页</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/25/Android开发艺术探索读书笔记/3. View的工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Android开发艺术探索读书笔记/3. View的工作原理/" itemprop="url">
                  View的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="ViewRoot-和-DecorView-……未完待续…"><a href="#ViewRoot-和-DecorView-……未完待续…" class="headerlink" title="ViewRoot 和 DecorView(……未完待续…..)"></a>ViewRoot 和 DecorView(……未完待续…..)</h1><p>在介绍他们之前 , 应该知道这些 :</p>
<blockquote>
<p>Activity通过PhoneWindow的setContentView方法来设置布局(<em>PhoneWindow是Android中的最基本的窗口系统,每个Activity 均会创建一个PhoneWindow对象</em>)，而设置布局之前，会先判断是否存在mDecor，如果是空 , PhoneWindow 则会创建一个DecorView . DecorView是整个ViewTree的最顶层View，它是一个FrameLayout布局，代表了整个应用的界面。</p>
</blockquote>
<h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h2><p>ViewRoot对应于ViewRootImpl类 , 他是链接WindoewManager和DeccorView的纽带 , View的三大流程均是通过ViewRoot来完成的 . ActivityThread中Activity对象被创建完毕后 , 会将DecorView添加到Window中 , 同时创建ViewRootImple对象 , 并将其与DecorView建立关联. View的绘制流程是从ViewRoot的performTraversals开始的 . 他经过measure , layout , draw 三个过程 . 分别为 测量View的宽高 , layout确定View的位置 , draw将View绘制出来 . 过程如下例 :</p>
<table>
<thead>
<tr>
<th style="text-align:center">performTraversals</th>
<th style="text-align:center">View</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">performMeasure -&gt; measure -&gt; onMeasure —-&gt;</td>
<td style="text-align:center">measure</td>
</tr>
</tbody>
</table>
<p>他分别完成顶级View的measure , layout , draw 三大流程 . 在onMeasure方法中 , 又会调用所有子元素的measure方法  , 子元素重复父容器的measure过程 . 这可能就是在相对布局中  , 有多少子元素就会调用多少次onMeasure方法的原因 . </p>
<p><strong>getMeasuredWidth / getWidth :</strong> 前者是最后一次对View内容测量后的宽度 , 后者是View在设定好布局后整个View的宽度 . 也就是说  一个是实际宽度 , 一个是全部的宽度 . 正常情况下两个值是一样的 , 返回的都是px的宽度 .</p>
<p>通过 findViewById(R.androdi.id.content); 就可以得到DecorView中的内容布局 , 也就是我们setContentView时候设置的布局了 . </p>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>…..</p>
<h1 id="理解MeasureSpec"><a href="#理解MeasureSpec" class="headerlink" title="理解MeasureSpec"></a>理解MeasureSpec</h1><p>MeasureSpec参与了View的测量过程 , 并起着决定性的作用 . 因为View的测量过程受父容器的影响 . 而父容器又影响View的MeasureSpec创建过程 . 在测量过程中 , 系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec , 然后再根据这个measureSpec来测量出View的宽高 . </p>
<p>MeasureSpec代表一个32位的int值 , 高2位代表SpecMode , 低30位代表SpecSize . 并提供了一个打包和解包的方法 . </p>
<p><strong>SpecMode </strong> 是指测量模式 :</p>
<p><strong>UNSPECIFIED : </strong>父容器不对View有任何限制,  要多大给多大, 这种情况一般用于系统内部 . 表示一直测量的状态.</p>
<p><strong>EXACTLY : </strong>父容器已经检测出View所需要的精确大小 , 这个事实View的最终大小就是SpecSize所指定的值. 对应LayoutParams中的match_parent .</p>
<p><strong>AT_MOST : </strong> 父容器指定了一个空大小 即 SpecSize . View的大小能大于这个值 , 具体是什么值要看不同View的具体实现 , 对应于LayoutParent中的wrap_content </p>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><p><strong>自定义View的分类:</strong></p>
<ol>
<li>继承View重写onDraw</li>
<li>继承ViewGroup派生特殊Layout</li>
<li>继承特定View 如TextView</li>
<li>继承特定ViewGroup 如LinearLayout</li>
</ol>
<p><strong>注意事项 : </strong></p>
<ol>
<li>让View支持wrap_content</li>
<li>让View支持padding</li>
<li>尽量不要使用Handler , 因为有了post系列的方法</li>
<li>线程和动画应及时停止 . View#onDetachedFromWindow方法在包含此View的Activity退出或被remove时被调用 , 对应的是onAttachedToWindow方法 . 除此之外 , 当View不可见时也应该停止线程 . </li>
<li>注意手势冲突</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/25/Android开发艺术探索读书笔记/1. Activity的启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Android开发艺术探索读书笔记/1. Activity的启动模式/" itemprop="url">
                  Activity的启动模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h1><p>默认情况下，Activity都存放在同一个任务栈中。</p>
<p>Activity有4中启动方式：分别为：</p>
<ul>
<li>standard 标准模式</li>
<li>singleTop 栈顶复用模式</li>
<li>singleTask 栈内复用模式</li>
<li>singleInstance 单实例模式</li>
</ul>
<p>默认情况下为standard。</p>
<h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>标准模式。每次启动一个Activity都会重新创建一个新的实例，如果A和B都是standard，那么如果启动A再启动B再启动A，那么栈中的情景就是ABA。</p>
<p>这个模式下的activity被谁启动，他就会加入到谁的栈中，所以用ApplicationContext去启动一个这样的activity的时候系统会报错，因为ApplicationContext并不是一个activity，他没有自己所属的栈。若非要这么干，可以指定Intent.FLAG_ACTIVITY_NEW_TASK标记，这样启动的时候就会为这个activity指定一个新的任务栈。</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>顶栈复用模式。如果被启动的activity已经在栈顶，那么这个activity就不会被再次创建，否则创建一个新的实例，保证不会产生两个相同的activity相邻。</p>
<p>如果被启动的activity在栈顶，那么再次启动它，它的onNewIntent()方法会被调用，onCreate, onStart不会被调用。</p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>栈内复用模式。如果栈中已经存在这个activity的实例，那么多次启动也不会被创建新的实例，只会调用onNewIntent方法，否则创建新的实例。举例来说栈中有ABCD，D为栈顶，此时D启动B，则栈中情况就变成了AB。是的……中间的就都销毁了……</p>
<p>任务栈中唯一，它的实例在任务栈中是唯一的。它在被Intent的时候，会先在系统中查找属性值affinty与它的属性值taskAffinity相同的任务栈是否存在，如果存在，则在这个任务启动，如果不在，则在新任务栈中启动。</p>
<p>之前还遇到过这样一个问题，B activity为singleTask模式，A使用startActivityForResult()方法启动B，奇怪的事情发生了，A的onActivityResult()在B启动的时候立即就被执行了，确切的说应该是除第一次启动完全正常没有被执行以外，其后每次启动B，A都会被立即调用onActivityResult()，将B的启动方式改为standard就没毛病了，   回立即调用onActivityResult()方法。搜了下发现了这个：</p>
<p><em>“Ams内部原理“10.1.3中有这样的一段话：请注意：SINGLE_TASK标识以及SINGLE_INSTANCE两个标识必须在r.result==0的条件中，即这两个标识只能用在startActivity()的方法中，而不能使用在startActivityForResult方法中。因为从Task的角度看，Android认为不同Task之间的Activity是不能传递数据的，所以不能使用NEW_TASK标识，但还是要调用forResult方法。”</em></p>
<p>也就是说这个模式不建议或者说不支持你使用startActivityForResult()启动再使用onActivityResult()方法接收数据，因为这个模式默认是为被启动的activity创建一个新的task，或者说将其加入到和他TaskAffinity相同的activity所存在的task中，只会出现这两种情况：1、系统中没有和他taskAffinity相同的activity，系统为其新建一个task。2、系统中有与他taskAffinity值相同的activity存在并已经有了所属栈，则将这个activity加到该栈中， 而Android认为不同Task之间的Activity是不能传递数据的，So……</p>
<p>这里有一个不知道对不对的地方就是，如果一个S1栈为ABCD，D为栈顶，此时D启动A，并且指定FLAG_ACTIVITY_NEW_TASK标记，那么此时是不是S1为ABCD，S2为A？不知道这种模式下指定FLAG_ACTIVITY_NEW_TASK管不管用。到目前为止我认为不管用。</p>
<p>你问什么是TaskAffinity？他是任务相关性。这个参数表示了一个activity所需要的任务栈的名字，默认情况下所有activity所需任务栈的名字都是应用的包名，我们可以为每个activity指定taskAffinity，记住不要和包名相同。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>单实例模式。这是singleTask的加强版，你可以这么认为：他是全局唯一的，它的实例在全局（即在众多任务栈中）是唯一的，它单独地存在于属于自己的任务栈中，而且这个任务栈没有其他实例。例如你在应用A中打开了百度地图的地图activity，并定位到了一个地区，如果这个activity是singleInstance模式，此时切换到百度地图，打开这个activity，他仍然是定位在这个地区的。</p>
<p>此模式下的activity被启动后系统会为其创建一个新的栈，在其他栈中启动这个activity，系统仍会来这个栈中找他。</p>
<p>需要注意的是下面这个例子：栈S1中为AB，栈S2也就是此类模式activity的聚集地中有CD，左底右顶，此时B启动D，则S1中就变成了ABCD。如果B启动了C，则S1中就是ABC，D被销毁了。</p>
<h1 id="设置启动模式"><a href="#设置启动模式" class="headerlink" title="设置启动模式"></a>设置启动模式</h1><p><strong>方法一：通过AndroidManifest文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.MainActivity&quot;</div><div class="line">     android:launchMode=&quot;singleTask&quot;&gt;</div></pre></td></tr></table></figure>
<p><strong>方式二：通过代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(ActivityA.<span class="keyword">this</span> , ActivityB.class);</div><div class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>第二种方式优先级高于第一种.</p>
<h1 id="Activity常用的Flags"><a href="#Activity常用的Flags" class="headerlink" title="Activity常用的Flags"></a><strong>Activity常用的Flags</strong></h1><p><strong>FLAG_ACTIVITY_NEW_TASK</strong></p>
<p>指定为singleTask模式</p>
<p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></p>
<p>指定为singleTop模式</p>
<p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></p>
<p>如果已经存在了,调用他的onNewIntent(),他之上的activity全部出栈.</p>
<p><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</strong></p>
<p>在用户使用最近任务的时候,该Task不会出现在最近任务中,等同于在XML中设置的android:excludeFromRecents=”true”</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/25/Android开发艺术探索读书笔记/4. View的事件体系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/Android开发艺术探索读书笔记/4. View的事件体系/" itemprop="url">
                  View的事件体系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-25T00:00:00+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h2><p>View的位置由4个顶点决定 , 分别对应<strong>top , left , right , bottom</strong> 如下图:</p>
<p><img src="http://a1.qpic.cn/psb?/V10u8paC0GE6gy/TJEim1JM4vCCMnDZSGSn48z2hXGsEVabjf29xwVdfA4!/b/dCABAAAAAAAA&amp;bo=jgGDAQAAAAADBy8!&amp;rf=viewer_4" alt=""></p>
<p>他们分别提供的get/set方法 , 注意他们都是相对于父控件的.</p>
<p>从Android3.0开始 , View增加了几个额外的参数 :</p>
<ol>
<li><strong>x , y  : </strong>View左上角坐标 , <em>x = translationX  + left;  y = translationY  + top;</em></li>
<li><strong>translationX , translationY  :  </strong>View左上角相对于父控件容器的偏移量.默认是0</li>
</ol>
<p>他们也都提供了get/set方法. 也是相对父控件的.</p>
<p><strong>注意 : </strong>View在平移的过程中 , top 和 left 并不会发生改变 , 他们保存的是左上角的原始位置 , 此时发生改变的是x , y , translationX , translationY这四个参数.</p>
<h2 id="MotionEvent-和TouchSlop"><a href="#MotionEvent-和TouchSlop" class="headerlink" title="MotionEvent 和TouchSlop"></a>MotionEvent 和TouchSlop</h2><h3 id="MotionEvent-事件对象"><a href="#MotionEvent-事件对象" class="headerlink" title="MotionEvent 事件对象"></a>MotionEvent 事件对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他是手指在屏幕上做出不同动作所产生的的事件对象 . 经常会在onTouchEvent()方法中看到他 .</p>
<p>常用:</p>
<p>public static final int ACTION_DOWN = 0; 手指刚接触屏幕</p>
<p>public static final int ACTION_MOVE = 2; 手指在屏幕上移动</p>
<p>public static final int ACTION_UP = 1; 手指抬开</p>
<p>非常用:</p>
<p>public static final int ACTION_CANCEL = 3;触摸动作取消</p>
<p>public static final int ACTION_OUTSIDE = 4;触摸动作超出边界</p>
<p>public static final int ACTION_POINTER_DOWN = 5;多点触摸动作</p>
<p>public static final int ACTION_POINTER_UP = 6;多点离开动作</p>
<p>该对象为我们提供了一些参数 , 来获取时间发生的坐标:</p>
<ol>
<li>getX/getY : 这个坐标相对于View左上角</li>
<li>getRawX/getRawY : 这个坐标相对于手机屏幕的左上角</li>
</ol>
<h3 id="TouchSlop-滑动最小距离"><a href="#TouchSlop-滑动最小距离" class="headerlink" title="TouchSlop 滑动最小距离"></a>TouchSlop 滑动最小距离</h3><p>TouchSlop是系统所能识别出的被认为是滑动的最小距离 , 也就是如果你的滑动距离小于这个值 ,那么久认为你没有在滑动 . 通过如下代码可以获取到这个值 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ViewConfiguration viewConfiguration = ViewConfiguration.get(context);</div><div class="line">viewConfiguration.getScaledTouchSlop();</div></pre></td></tr></table></figure>
<p>他和设备有关 , 不同的设备这个值的大小也不同 , 默认为8dp , 我们可以利用他来过滤掉那些并非滑动的滑动 .</p>
<h2 id="VelocityTracker-GestureDetector"><a href="#VelocityTracker-GestureDetector" class="headerlink" title="VelocityTracker , GestureDetector"></a>VelocityTracker , GestureDetector</h2><h3 id="VelocityTracker-速度追踪"><a href="#VelocityTracker-速度追踪" class="headerlink" title="VelocityTracker 速度追踪"></a>VelocityTracker 速度追踪</h3><p>速度追踪 , 用于追踪手指滑动时的速度 , 使用 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">VelocityTracker tracker = VelocityTracker.obtain();</div><div class="line">tracker.addMovement(event);</div><div class="line">tracker.computeCurrentVelocity(<span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="keyword">float</span> xVelocity = tracker.getXVelocity();</div><div class="line"><span class="keyword">float</span> yVelocity = tracker.getYVelocity();</div></pre></td></tr></table></figure>
<p>只需要将MotionEvent事件传递进去就可以了 , computeCurrentVelocity()方法是必须设置的 , 他决定了获取手指在多长时间内划过的像素点 , 所以这里的getXVelocity()方法获取的就是1秒内手指划过了多少像素点 . </p>
<p>速度 = (终点 - 起点) / 时间段</p>
<p><strong>注意 :</strong> 在使用完之后 , 需要调用clear方法来重置并回收内存 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tracker.clear();</div><div class="line">tracker.recycle();</div></pre></td></tr></table></figure>
<h3 id="GestureDetector-手势识别"><a href="#GestureDetector-手势识别" class="headerlink" title="GestureDetector 手势识别"></a>GestureDetector 手势识别</h3><p>手势识别 , 用于辅助检测用户的单击, 滑动 , 长按 , 双击等行为 . </p>
<p>以下是他的使用方法 , OnGestureListener和OnDoubleTapListener可以选择性的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span> , <span class="title">GestureDetector</span>.<span class="title">OnDoubleTapListener</span></span>&#123;</div><div class="line"></div><div class="line">    GestureDetector mGestureDetector;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        <span class="comment">// 创建GestureDetector</span></div><div class="line">        mGestureDetector = <span class="keyword">new</span> GestureDetector(context , <span class="keyword">this</span>);</div><div class="line">        mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">// 将MotionEven传给他</span></div><div class="line">        <span class="keyword">boolean</span> b = mGestureDetector.onTouchEvent(event);</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">// ---------------------OnGestureListener---------------------</span></div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 手指轻按屏幕</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 手指轻按屏幕 , 尚未松开或拖动 , 和onDown的区别在于他多了后面的  "尚未松开或拖动"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 单击行为</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 拖动行为</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 长按动作</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 快速滑动动作</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ---------------------OnDoubleTapListener---------------------</span></div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 严格的单击行为 ,</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 双击动作</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO 发生了双击行为</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>常用 : </strong> 并不是每个方法都会经常用到 , 常用的有:</p>
<p>onSingleTapUp 单击</p>
<p>onFling 滑动</p>
<p>onScroll 拖动</p>
<p>onLongPress 长按</p>
<p>onDoubleTap 双击</p>
<p><strong>建议 : </strong>如果只是监听滑动相关 , 则自己在onTouchEvent中实现 , 如果是监听双击的话就用GestureDetector . </p>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><h3 id="使用scrollTo-scrollBy"><a href="#使用scrollTo-scrollBy" class="headerlink" title="使用scrollTo / scrollBy"></a>使用scrollTo / scrollBy</h3><p>scrollBy实际上也是调用了scrollTo , 两者的区别在于 : </p>
<ol>
<li>scrollBy : 基于当前位置的相对滑动</li>
<li>scrollTo : 基于所传递参数的绝对滑动</li>
</ol>
<p><strong>注意 : </strong>他们都只能改变View内容的位置 , 而不能改变View在布局中的位置 .</p>
<p>下面是他们滚动方向的图像示例 : </p>
<p><img src="http://img.blog.csdn.net/20170210104205022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk4NDA1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>这种方式只需要提醒一点就是 , 如果用属性动画的话 , 可以使View的真实位置改变 , 而采用传统的动画则只是改变了View的translationX和translationY , 真实位置没有发生变化 , 如果是一个需要交互的View , 那么这种方式是不可行的 . </p>
<p>如果没有交互 , 就使用传统动画 , 比较简单 </p>
<p>如果有交互  , 就使用属性动画 , 通过在onAnimationUpdate()方法中改变View的布局来实现 . </p>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>弹性滑动对象 , 直接使用scrollTo/scrollBy进行滑动 , 其过程是瞬间的 , Scroller可以实现有过度效果的滑动.</p>
<p>典型实现 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</div><div class="line"></div><div class="line">    Scroller mScroller;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        mScroller = <span class="keyword">new</span> Scroller(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</div><div class="line">            scrollTo(mScroller.getCurrX() , mScroller.getCurrY());</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始平滑滚动</div><div class="line">     * 此处为1秒钟滚动到指定的坐标</div><div class="line">     * <span class="doctag">@param</span> destX</div><div class="line">     * <span class="doctag">@param</span> destY</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX , <span class="keyword">int</span> destY)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">        <span class="keyword">int</span> delta = destX - scrollX;</div><div class="line">        mScroller.startScroll(scrollX , <span class="number">0</span> , delta , <span class="number">0</span> , <span class="number">1000</span>);</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的重点是Scroller对象 , 上面代码的调用顺序为: 用户调用smoothScrollTo()方法 , 在这个方法中 , 传入了指定坐标 , 通过这个坐标算出了需要滑动的距离 , 然后将这个距离设置给了Scroller对象 , 调用了startScroll()方法 , 其实这个方法什么功能也没有 , 他仅仅是记录了一些所需要的信息 , 比如当前位置 , 滚动时间等等 . 然后紧跟着发了一个invalidate() , 让view重绘 ,  而在View的draw方法中就会去调用computeScroll了 , 这个方法原本是个空实现 , 而现在被重写, 在里面调用了 computeScrollOffset() , 这个方法厉害了 , 前面的startScroll方法将View的一些值记录了下来 , 而computeScrollOffset方法则会根据时间的流逝将对应的值改变 , 所以在执行过一computeScrollOffset方法之后 , Scroller对象中的值都更新了 , 所以在下面调用scrollTo方法时 , 传入的参数mScroller.getCurrX()则是当前时间这个View的X轴该在的地方 . 然后又发送postInvalidate()重复上面的过程  , computeScrollOffset()返回true时 , 表示滑动还未结束 , 否则反之 .</p>
<h2 id="View事件冲突"><a href="#View事件冲突" class="headerlink" title="View事件冲突"></a>View事件冲突</h2><p>暂且不写….</p>
<h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>还记得MotionEvent么 , 事件对象 , 当一个事件对象产生时 , 谁去处理它 ? 如何处理 ? </p>
<h3 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h3><p>首先要知道非常重要的三个方法 : </p>
<ol>
<li><strong>dispatchTouchEvent :</strong> 用来进行事件的分发 ,  如果事件能够传递给当前View , 那么此方法一定会被调用 , 返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent影响 , 表示是否消耗当前事件 .</li>
<li><strong>onInterceptTouchEvent :</strong> 在上述方法内部调用 , 用来判断是否拦截某个事件 , 如果当前View拦截了某个事件, 那么在同一个事件序列当中,  此方法不会再次被调用 , 返回结果表示是否拦截当前事件 .</li>
<li><strong>onTouchEvent :</strong> 在dispatchTouchEvent中调用 , 返回值表示是否消耗当前事件 , 如果不消耗 , 则在同一个事件序列中无法再次接收到事件 .</li>
</ol>
<p>这是ViewGroup中的一段伪代码 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</div><div class="line">        consume = onTouchEvent(event);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        consume = child.dispatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码简单说明了他们之间的关系 .  一个事件产生后 , 首先会调用最外层父控件的dispatchTouchEvent() , 如果onInterceptTouchEvent 返回true决定拦截 , 那么就不再向下传递 , 而是调用自己的onTouchEvent , 否则将调用子View的 dispatchTouchEvent 方法 . </p>
<p>如果对某个View设置了 onTouchListener 那么先执行onTouchListener中的onTouch , 如果该方法返回true , 则onTouchEvent方法不再被调用 . </p>
<p><strong>相关总结 :</strong> </p>
<ol>
<li>同一个事件序列是指从手指按下到离开 . </li>
<li>正常情况下 , 一个事件序列只被一个View拦截且消耗 .</li>
<li>某个View一旦决定拦截 , 那么这个事件序列都只能由他来处理 . 并且onInterceptTouchEvent在一个事件序列中只会被调用一次 . </li>
<li>一个View在处理事件的时候 , 如果不消耗ACTION_DOWN事件 , 那么同一序列的事件都不会再交由它处理 . </li>
<li>如果只处理了ACTION_DOWN事件 , 其他的都没有处理 , 那么这个点击事件将消失. </li>
<li>ViewGroup默认不拦截任何事件 .</li>
<li>View没有onInterceptOuchEvnet方法,  一旦有点击事件, 那么onTouchEvent将会被调用 . </li>
<li>不可点击的View(如TextView) , 他的clickable和longClickable都是false  , 如果其中有一项为true  , 那么他的onTouchEvent返回true  , setOnclickListener会将clicable设置为true . </li>
<li>enable 属性不影响onTouchEvent的默认返回值 . 哪怕他是一个disable状态 . </li>
<li>通过requestDisallowInterceptTouchEvent方法可以在子View中干预父控件的事件分发过程 .ACTION_DOWN除外.</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/设计模式/设计模式之 状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.LongFace">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr.LongFace">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/设计模式/设计模式之 状态模式/" itemprop="url">
                  设计模式之 状态模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T00:00:00+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <ul>
<li>如果代码中出现大量与对象状态有关的条件语句，并且这些语句会导致代码的可维护性和灵活性变差。不能方便的增加和删除状态。（主要适用场景）</li>
<li>如果对象的行为依赖于他的状态，状态的改变将导致行为的变化。（这一点跟策略模式很像）</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/24/设计模式/设计模式之 状态模式/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="Mr.LongFace" />
          <p class="site-author-name" itemprop="name">Mr.LongFace</p>
           
              <p class="site-description motion-element" itemprop="description">一个瞎BB的人</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.LongFace</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
